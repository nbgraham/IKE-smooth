
# This file was *autogenerated* from the file run.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_113038384112950627112915298112892539 = Integer(113038384112950627112915298112892539); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF); _sage_const_10 = Integer(10); _sage_const_1000 = Integer(1000); _sage_const_15 = Integer(15); _sage_const_27 = Integer(27); _sage_const_1 = Integer(1); _sage_const_100000 = Integer(100000)
import time
import multiprocessing

p = _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF 
p_squared = p**_sage_const_2 
pref = _sage_const_113038384112950627112915298112892539  # 0b101011100010100111000111111100000010010001110000011111111111101001010000000011010101010011001011001011110111001111011

min_max_prime_factor = p
bestResult = (float("inf"),pref,_sage_const_0 )

small_primes = primes_first_n(_sage_const_100000 )

new_results = []
count_As_factored = _sage_const_1 

start_time = time.time()


start_from_checkpoint = _sage_const_1 
# 113038384112950627112915298112892539006000000000000000000000000000000000000000000 for 10000 primes


def batch_gen(gen, batch_start, batch_size):
	yield batch_start
	for _ in range(batch_size-_sage_const_1 ):
		batch_i = next(gen)
		if batch_i is not None:
			yield batch_i
		else:
			break


def batchify(gen, batch_size):
	batch_start = next(gen, None)
	while batch_start is not None:
		yield batch_gen(gen, batch_start, batch_size)
		batch_start = next(gen,None)


def smart_search(bit_chop):
    threshold = p >> bit_chop
    bin_prefix = '1'+'0'*bit_chop

    giant_step = _sage_const_2 .powermod(bit_chop,p)

    space_size = _sage_const_10 **_sage_const_10 
    a = pref * space_size
    r = _sage_const_2 .powermod(a,p)
    
    for i in range(_sage_const_10 ,_sage_const_100 ):
        count = _sage_const_0 
        while count < space_size:
            if r <= threshold:
                yield (a,r)
            elif not str.startswith(r.binary(), bin_prefix):
                a += bit_chop
                r = (r * giant_step) % p
            else:
                a += _sage_const_1 
                r = r*_sage_const_2  if r <= half_p else (r*_sage_const_2 ) - p
            count += _sage_const_1 
        space_size *= _sage_const_10 
        a *= _sage_const_10 
        r = r.powermod(_sage_const_10 ,p)
                           

def power_max_prime_fact(input):
	global bestResult, new_results, count_As_factored
	
	(A,n) = input
	p_offset = _sage_const_0 

	if n == _sage_const_1  or is_pseudoprime(n) and is_prime(n):
		max_p_fact = n
		count_As_factored += _sage_const_1 
	else:
		max_p = _sage_const_0 
		max_p_fact = float("inf")
		
		cur_n = n
		for fac in small_primes:
			while cur_n % fac == _sage_const_0 :
				cur_n = cur_n // fac
				max_p = fac

		if cur_n == _sage_const_1  or is_pseudoprime(cur_n) and is_prime(cur_n):
			max_p_fact = max(cur_n, max_p)
			
			# If it is promising also try adding p's to RHS since that will be equivalent mod p
			if max_p_fact < bestResult[_sage_const_0 ]:
				print 'time', int(time.time()-start_time), 'Possible best A found', A
				start = time.time()
				n_eq = n + p
				count_p = _sage_const_1 
				while count_p < _sage_const_10  and n_eq < p_squared:
					mod_max_p_fact = max_prime_fact(n_eq)
					if mod_max_p_fact < max_p_fact:
						max_p_fact = mod_max_p_fact
						p_offset = count_p
					n_eq = n_eq + p
					count_p += _sage_const_1 
				# print 'Checking mod p took', time.time() - start, 'seconds'

			if count_As_factored % _sage_const_100  == _sage_const_0 :
				bestResult = min([min(new_results),bestResult])
				new_results = []
			count_As_factored += _sage_const_1 

	# if A % pref == 0:
	# 	print 'time', int(time.time()-start_time), 'bestA', bestResult[1], 'bestOffset', bestResult[2]
	
	result = (max_p_fact,A,p_offset)
	new_results.append(result)
	return result


def max_prime_fact(cur_n):
	if cur_n == _sage_const_1  or is_pseudoprime(cur_n) and is_prime(cur_n):
		max_p_fact = cur_n
	else:
		max_p = _sage_const_0 
		max_p_fact = float("inf")
		
		for fac in small_primes:
			while cur_n % fac == _sage_const_0 :
				cur_n = cur_n // fac
				max_p = fac

		if cur_n == _sage_const_1  or is_pseudoprime(cur_n) and is_prime(cur_n):
			max_p_fact = max(cur_n, max_p)

	return max_p_fact


def seq():
	global bestResult
	for (A,n) in smart_search(_sage_const_27 ):
		(max_p_fact,A,p_offset) = power_max_prime_fact((A,n))
		if max_p_fact < bestResult[_sage_const_0 ]:
			bestResult = (max_p_fact,A)
	bestA = bestResult[_sage_const_1 ]
	p_offset = bestResult[_sage_const_2 ]

	return  bestA, p_offset


def par():
	pool = multiprocessing.Pool(_sage_const_3 )
	
	batch_count = _sage_const_0 
	bestResult = (p,_sage_const_0 ,_sage_const_0 )
	for batch_generator in batchify(smart_search(_sage_const_27 ),_sage_const_1000 ):
		out = zip(*pool.map(power_max_prime_fact, batch_generator))
		result = min(zip(*out))

		if result[_sage_const_0 ] < bestResult:
			bestResult = result

		batch_count += _sage_const_1 
		print 'Batch', batch_count, 'bestA', bestResult[_sage_const_1 ], 'with p offset', bestResult[_sage_const_2 ]

	max_p_factor = bestResult[_sage_const_0 ]
	bestA = bestResult[_sage_const_1 ]
	p_offset = bestResult[_sage_const_2 ]

	return bestA, p_offset

def main():	
	start = time.time()

	bestA, p_offset = par()

	print
	print '-'*_sage_const_15 
	print '-'*_sage_const_15 
	print "A=", bestA
	print "offset by p*", p_offset
	print "2^A=", factor(_sage_const_2 .powermod(bestA,p) + p*p_offset)

	runtime = time.time() - start
	print runtime, "seconds"


if __name__ == '__main__':
	main()

