
# This file was *autogenerated* from the file test_search_space.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_113038384112950627112915298112892539 = Integer(113038384112950627112915298112892539); _sage_const_0 = Integer(0); _sage_const_342 = Integer(342); _sage_const_100 = Integer(100); _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF); _sage_const_10 = Integer(10); _sage_const_1000 = Integer(1000); _sage_const_1 = Integer(1)
import time

pref = _sage_const_113038384112950627112915298112892539  # 0b101011100010100111000111111100000010010001110000011111111111101001010000000011010101010011001011001011110111001111011

p = _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF 
half_p = p //_sage_const_2 

def search_space_(base=pref*_sage_const_100 ):
    step = _sage_const_1 
    for power in range(_sage_const_3 ,_sage_const_342 ):
        base = base * _sage_const_10 
        val = base
        r = _sage_const_2 .powermod(val,p)
        step_r = _sage_const_2 .powermod(step,p)
        for i in range(_sage_const_1000 ):
            yield (val, r)
            val = val + step
            r = (r*step_r)%p
        step = step * _sage_const_10  


def smart_search(bit_chop):
    threshold = p >> bit_chop
    bin_prefix = '1'+'0'*bit_chop

    giant_step = _sage_const_2 .powermod(bit_chop,p)

    space_size = _sage_const_10 **_sage_const_10 
    a = pref * space_size
    r = _sage_const_2 .powermod(a,p)
    
    for i in range(_sage_const_10 ,_sage_const_100 ):
        count = _sage_const_0 
        while count < space_size:
            if r <= threshold:
                yield (a,r)
            elif not str.startswith(r.binary(), bin_prefix):
                a += bit_chop
                r = (r * giant_step) % p
            else:
                a += _sage_const_1 
                r = r*_sage_const_2  if r <= half_p else (r*_sage_const_2 ) - p
            count += _sage_const_1 
        space_size *= _sage_const_10 
        a *= _sage_const_10 
        r = r.powermod(_sage_const_10 ,p)


# Garbage
def search_space():
    b = pref * _sage_const_100 
    for i in range(_sage_const_100 ):
        gen = search_space_(b+i)
        for (a,r) in gen:
            if r <= threshold:
                yield (a,r)
    print("Checked all possible values")
        

def test(gen):
    i = _sage_const_0 
    sizes = []
    for (a,r) in gen:
        sizes.append(len(r.binary()))
        i += _sage_const_1 
        if i > _sage_const_100 :
            break
    return sum(sizes)/len(sizes)


def main():
    b = int(sys.argv[_sage_const_1 ])
    start = time.time()
    avg_size = test(smart_search(b))
    print (avg_size)
    print(time.time() - start)


if __name__ == '__main__':
    main()

