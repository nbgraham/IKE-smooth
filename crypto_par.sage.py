
# This file was *autogenerated* from the file crypto_par.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_113038384112950627112915298112892539 = Integer(113038384112950627112915298112892539); _sage_const_0 = Integer(0); _sage_const_342 = Integer(342); _sage_const_100 = Integer(100); _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF); _sage_const_10 = Integer(10); _sage_const_1000 = Integer(1000); _sage_const_15 = Integer(15); _sage_const_1 = Integer(1)
import time
import multiprocessing

p = _sage_const_0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF 
pref = _sage_const_113038384112950627112915298112892539  # 0b101011100010100111000111111100000010010001110000011111111111101001010000000011010101010011001011001011110111001111011

min_max_prime_factor = p
bestResult = (float("inf"),pref)

small_primes = primes_first_n(_sage_const_100 )

new_results = []
old_results = []
count_As_factored = _sage_const_1 


def search_space():
	base = pref*_sage_const_100 
	step = pref
	for power in range(_sage_const_3 ,_sage_const_342 ):
		base = base * _sage_const_10 
		for i in range(_sage_const_1000 ):
			yield (base + i)
		step = step * _sage_const_10  
                           

def max_prime_fact(A):
	cur_n = _sage_const_2 .modpower(A,p)

	if cur_n == _sage_const_1  or is_pseudoprime(cur_n) and is_prime(cur_n):
		max_p_fact = cur_n
		count_As_factored += _sage_const_1 
	else:
		max_p = _sage_const_0 
		max_p_fact = float("inf")
		
		for fac in small_primes:
			while cur_n % fac == _sage_const_0 :
				cur_n = cur_n // fac
				max_p = fac

		if cur_n == _sage_const_1  or is_pseudoprime(cur_n) and is_prime(cur_n):
			max_p_fact = max(cur_n, max_p)
			if count_As_factored % _sage_const_100  == _sage_const_0 :
				bestResult = min([min(new_results),bestResult])
				old_results += new_results
				new_results = []
			count_As_factored += _sage_const_1 

	if A % pref == _sage_const_0 :
		print 'time', int(time.time()), 'A', A, 'bestA', bestA
		
	result = (max_p_fact,A)
	new_results.append(result)
	return result


def main():
	start = time.time()

	pool = multiprocessing.Pool(_sage_const_3 )
	out = zip(*pool.map(max_prime_fact, search_space()))
	result = min(zip(*out))

	mess = result[_sage_const_0 ]
	bestA = result[_sage_const_1 ]

	print
	print '-'*_sage_const_15 
	print '-'*_sage_const_15 
	print "A=", bestA
	print "2^A=", factor(_sage_const_2 .modpower(bestA,p))

	runtime = time.time() - start
	print runtime, "seconds"


if __name__ == '__main__':
	main()

